import time
import multiprocessing

# 멀티프로세스 활용하면 데이터공유 안됨. but 스레드로 하면 더 느려질 거 프로세스로 처리하면 빨라질 수 있다.
'''
CPU 바운드 작업:

작업이 CPU 리소스에 크게 의존하는 경우, 멀티스레딩은 GIL (Global Interpreter Lock, CPython에서만 해당)로 인해 한 번에 하나의 스레드만 실행될 수 있습니다. 멀티프로세싱은 각 프로세스가 독립적인 메모리 공간과 GIL을 가지므로 여러 CPU 코어에서 동시에 실행될 수 있습니다. 따라서 CPU 집중적인 작업의 경우 멀티프로세싱이 멀티스레딩보다 효율적일 수 있습니다.
메모리 독립성:

멀티프로세싱은 각 프로세스가 독립적인 메모리 공간을 가집니다. 이로 인해 한 프로세스에서 발생한 오류나 메모리 누수가 다른 프로세스에 영향을 미치지 않습니다. 반면, 멀티스레딩에서는 모든 스레드가 같은 메모리 공간을 공유하므로, 하나의 스레드에서 발생한 문제가 다른 스레드에 영향을 미칠 수 있습니다.
데이터의 독립성:

멀티프로세스 방식에서 각 프로세스는 독립적인 메모리 공간을 가지므로, 데이터의 독립성이 필요한 작업에 적합합니다. 멀티스레딩에서는 스레드 간에 데이터를 공유하므로 동기화 문제를 주의해야 합니다.
장기 실행 작업:

특정 작업이 오랜 시간 동안 실행되어야 하는 경우, 멀티프로세스 방식은 프로세스 간의 독립성으로 인해 더 안정적일 수 있습니다.
특정 라이브러리나 확장의 호환성:

일부 라이브러리나 C 확장은 멀티스레딩과 호환되지 않을 수 있습니다. 이러한 경우 멀티프로세싱을 사용하는 것이 더 적합할 수 있습니다.
'''

def count_num(name):
    cnt = 0
    for _ in range(1000000):
        cnt += 1
    print(f"{name} Done")

def func1():
    start = time.time()

    with multiprocessing.Pool(processes=3) as pool:
        pool.map(count_num, range(3))

    end = time.time()
    delta = end-start
    print(f"총 시간: {delta:.3f} sec")
    
if __name__ == "__main__":
    func1()